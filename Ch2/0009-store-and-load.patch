diff --git a/llvm/lib/Target/Toy/Disassembler/ToyDisassembler.cpp b/llvm/lib/Target/Toy/Disassembler/ToyDisassembler.cpp
index 3d4ea3f58fc7..ad8693497304 100644
--- a/llvm/lib/Target/Toy/Disassembler/ToyDisassembler.cpp
+++ b/llvm/lib/Target/Toy/Disassembler/ToyDisassembler.cpp
@@ -59,7 +59,10 @@ static const uint16_t GPRDecoderTable[] = {
 static DecodeStatus DecodeGPRRegisterClass(MCInst &Inst, uint64_t RegNo,
                                            uint64_t Address,
                                            const void *Decoder) {
-  if (RegNo > 31)
+  if (RegNo > 17)
+    return MCDisassembler::Fail;
+
+  if (RegNo == 3 || RegNo == 4)
     return MCDisassembler::Fail;
 
   unsigned Register = GPRDecoderTable[RegNo];
@@ -67,6 +70,44 @@ static DecodeStatus DecodeGPRRegisterClass(MCInst &Inst, uint64_t RegNo,
   return MCDisassembler::Success;
 }
 
+static const uint16_t FPRDecoderTable[] = {
+    Toy::FT0, Toy::FT1, Toy::FT2, 0,        0,        0,
+    0,        0,        Toy::FS0, Toy::FS1, Toy::FA0, Toy::FA1,
+    Toy::FA2, Toy::FA3, Toy::FA4, Toy::FA5, Toy::FA6, Toy::FA7};
+
+static DecodeStatus DecodeFPRRegisterClass(MCInst &Inst, uint64_t RegNo,
+                                           uint64_t Address,
+                                           const void *Decoder) {
+  if (RegNo > 17)
+    return MCDisassembler::Fail;
+
+  if (RegNo == 3 || RegNo == 4 || RegNo == 5 || RegNo == 6 || RegNo == 7)
+    return MCDisassembler::Fail;
+
+  unsigned Register = FPRDecoderTable[RegNo];
+  Inst.addOperand(MCOperand::createReg(Register));
+  return MCDisassembler::Success;
+}
+
+static const uint16_t FPR64DecoderTable[] = {
+    Toy::FT0, Toy::FT1, Toy::FT2, 0,        0,        0,
+    0,        0,        Toy::FS0, Toy::FS1, Toy::FA0, Toy::FA1,
+    Toy::FA2, Toy::FA3, Toy::FA4, Toy::FA5, Toy::FA6, Toy::FA7};
+
+static DecodeStatus DecodeFPR64RegisterClass(MCInst &Inst, uint64_t RegNo,
+                                             uint64_t Address,
+                                             const void *Decoder) {
+  if (RegNo > 17)
+    return MCDisassembler::Fail;
+
+  if (RegNo == 3 || RegNo == 4 || RegNo == 5 || RegNo == 6 || RegNo == 7)
+    return MCDisassembler::Fail;
+
+  unsigned Register = FPR64DecoderTable[RegNo];
+  Inst.addOperand(MCOperand::createReg(Register));
+  return MCDisassembler::Success;
+}
+
 #include "ToyGenDisassemblerTables.inc"
 
 DecodeStatus ToyDisassembler::getInstruction(MCInst &MI, uint64_t &Size,
diff --git a/llvm/lib/Target/Toy/ToyISelDAGToDAG.cpp b/llvm/lib/Target/Toy/ToyISelDAGToDAG.cpp
index 5300fdd1f918..2b8f78abb7ae 100644
--- a/llvm/lib/Target/Toy/ToyISelDAGToDAG.cpp
+++ b/llvm/lib/Target/Toy/ToyISelDAGToDAG.cpp
@@ -37,7 +37,8 @@ public:
 
   // Override SelectionDAGISel.
   void Select(SDNode *Node) override;
-
+  bool SelectAddrFI(SDNode *Parent, SDValue Addr, SDValue &Base,
+                    SDValue &Offset);
 // Include the pieces autogenerated from the target
 // description.
 #include "ToyGenDAGISel.inc"
@@ -54,10 +55,31 @@ FunctionPass *llvm::createToyISelDag(ToyTargetMachine &TM,
 }
 
 void ToyDAGToDAGISel::Select(SDNode *Node) {
-  // Instruction Selection not handled by the
-  // auto-generated tablegen selection should be handled
-  // here.
-
+  if (Node->isMachineOpcode()) {
+    Node->setNodeId(-1);
+    return;
+  }
   // Select the default instruction.
   SelectCode(Node);
 }
+
+bool ToyDAGToDAGISel::SelectAddrFI(SDNode *Parent, SDValue Addr, SDValue &Base,
+                                   SDValue &Offset) {
+  EVT ValTy = Addr.getValueType();
+  SDLoc DL(Addr);
+  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
+    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), ValTy);
+    Offset = CurDAG->getTargetConstant(0, DL, ValTy);
+    return true;
+  }
+  if (CurDAG->isBaseWithConstantOffset(Addr)) {
+    ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1));
+    if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr.getOperand(0)))
+      Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), ValTy);
+    else
+      Base = Addr.getOperand(0);
+    Offset = CurDAG->getTargetConstant(CN->getZExtValue(), DL, ValTy);
+    return true;
+  }
+  return false;
+}
diff --git a/llvm/lib/Target/Toy/ToyInstrInfo.td b/llvm/lib/Target/Toy/ToyInstrInfo.td
index f70fab056d26..9280a34427a3 100644
--- a/llvm/lib/Target/Toy/ToyInstrInfo.td
+++ b/llvm/lib/Target/Toy/ToyInstrInfo.td
@@ -23,15 +23,18 @@ def J : InstJ<0b1101111, (outs),(ins brtarget:$imm20),
 def JALR : InstI<0b1100111, 0b000, (outs GPR:$rd), (ins GPR:$rs1, imm12:$imm),
       "jalr\t$rd, $rs1, $imm", []>;
 
-def RET : ToyPseudo<(outs),(ins),"",[(ToyRET)]>, PseudoInstExpansion<(JALR ZERO, RA, 0)> {
+def RET : ToyPseudo<(outs), (ins), "", [(ToyRET)]>, 
+                    PseudoInstExpansion<(JALR ZERO, RA, 0)> {
   let isReturn = 1;
   let isTerminator=1;
   let isPseudo = 1;
 }
 
 def SDT_Call : SDTypeProfile<0, 1, [SDTCisVT<0, iPTR>]>;
-def ToyCall  : SDNode<"ToyISD::Call", SDT_Call, [SDNPHasChain, SDNPOutGlue, SDNPOptInGlue, SDNPVariadic]>;
-def CALL     : ToyPseudo<(outs),(ins GPR:$rs1),"",[(ToyCall GPR:$rs1)]>, PseudoInstExpansion<(JALR RA, GPR:$rs1, 0)> {
+def ToyCall  : SDNode<"ToyISD::Call", SDT_Call, 
+               [SDNPHasChain, SDNPOutGlue, SDNPOptInGlue, SDNPVariadic]>;
+def CALL     : ToyPseudo<(outs), (ins GPR:$rs1), "",
+               [(ToyCall GPR:$rs1)]>, PseudoInstExpansion<(JALR RA, GPR:$rs1, 0)> {
   let isCall = 1;
 }
 
@@ -43,22 +46,74 @@ class ArithLogicI <bits<7> opcode, bits<3> funct3, string inst, SDNode node>:
       !strconcat(inst, "\t$rd, $rs1, $imm"),
       [(set GPR:$rd, (node GPR:$rs1, imm12:$imm))]>;
 
-def ADDI : ArithLogicI<0b0010011, 0b000, "addi", add>;
+let isReMaterializable = 1 in
+  def ADDI : ArithLogicI<0b0010011, 0b000, "addi", add>;
+
+let isReMaterializable = 1 in {
+  def ORI  : ArithLogicI<0b0010011, 0b110, "ori", or>;
+  def XORI : ArithLogicI<0b0010011, 0b100, "xori", xor>;
+}
+
 def ANDI : ArithLogicI<0b0010011, 0b111, "andi", and>;
-def ORI : ArithLogicI<0b0010011, 0b110, "ori", or>;
-def XORI : ArithLogicI<0b0010011, 0b100, "xori", xor>;
 
 class ArithLogicR <bits<7> funct7, bits<3> funct3, string inst, SDNode node>:
       InstR<0b0110011, funct7, funct3, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
       !strconcat(inst, "\t$rd, $rs1, $rs2"),
       [(set GPR:$rd, (node GPR:$rs1, GPR:$rs2))]>;
 
-def ADD : ArithLogicR<0b0000000, 0b000, "add", add>;
-def SUB : ArithLogicR<0b0100000, 0b000, "sub", sub>;
-def MUL : ArithLogicR<0b0000001, 0b000, "mul", mul>;
+let isCommutable = 1 in {
+  def ADD  : ArithLogicR<0b0000000, 0b000, "add", add>;
+}
+
+def SUB  : ArithLogicR<0b0100000, 0b000, "sub", sub>;
+def MUL  : ArithLogicR<0b0000001, 0b000, "mul", mul>;
 def MULH : ArithLogicR<0b0000001, 0b001, "mulh", mulhs>;
-def DIV : ArithLogicR<0b0000001, 0b100, "div", sdiv>;
-def REM : ArithLogicR<0b0000001, 0b110, "rem", srem>;
-def AND : ArithLogicR<0b0000000, 0b111, "and", and>;
-def OR  : ArithLogicR<0b0000000, 0b110, "or", or>;
-def XOR : ArithLogicR<0b0000000, 0b100, "xor", xor>;
+def DIV  : ArithLogicR<0b0000001, 0b100, "div", sdiv>;
+def REM  : ArithLogicR<0b0000001, 0b110, "rem", srem>;
+def AND  : ArithLogicR<0b0000000, 0b111, "and", and>;
+def OR   : ArithLogicR<0b0000000, 0b110, "or", or>;
+def XOR  : ArithLogicR<0b0000000, 0b100, "xor", xor>;
+def SLL  : ArithLogicR<0b0000000, 0b001, "sll", shl>;
+def SRA  : ArithLogicR<0b0100000, 0b101, "sra", sra>;
+def SRL  : ArithLogicR<0b0000000, 0b101, "srl", srl>;
+
+def AddrFI : ComplexPattern<iPTR, 2, "SelectAddrFI", [frameindex], [SDNPWantParent]>;
+
+// load/store for data types
+multiclass STORE<bits<7> opcode, bits<3> funct3, PatFrag op, string asm, DAGOperand ty> {
+  def FI : InstS<opcode, funct3, (outs), 
+           (ins ty:$rs2, GPR:$rs1, imm12:$imm),
+           !strconcat(asm, "\t$rs2, ${imm}(${rs1})"),
+           [(op ty:$rs2, (AddrFI GPR:$rs1, imm12:$imm))]>;
+  def R : InstS<opcode, funct3, (outs),
+          (ins ty:$rs2, GPR:$rs1),
+          !strconcat(asm, "\t$rs2, 0(${rs1})"),
+          [(op ty:$rs2, GPR:$rs1)]> {
+      let imm=0;
+  }
+}
+
+defm STOREW : STORE<0b0100011, 0b010, store, "sw", GPR>;
+defm STOREH : STORE<0b0100011, 0b001, truncstorei16, "sh", GPR>;
+defm STOREB : STORE<0b0100011, 0b000, truncstorei8, "sb", GPR>;
+defm STORF  : STORE<0b0100111, 0b010, store, "fsw", FPR>;
+defm STORD  : STORE<0b0100111, 0b011, store, "fsd", FPR64>;
+
+multiclass LOAD<bits<7> opcode, bits<3> funct3, PatFrag op, string asm, DAGOperand ty> {
+  def FI : InstI<opcode, funct3, (outs ty:$rd),
+                 (ins GPR:$rs1, imm12:$imm),
+                 !strconcat(asm, "\t$rd, ${imm}(${rs1})"),
+                 [(set ty:$rd, (op (AddrFI GPR:$rs1, imm12:$imm)))]>;
+  def R : InstI<opcode, funct3,
+                (outs ty:$rd), (ins GPR:$rs1),
+                !strconcat(asm, "\t$rd, 0(${rs1})"),
+                [(set ty:$rd, (op GPR:$rs1))]>{
+      let imm=0;
+  }
+}
+
+defm LOADW  : LOAD<0b0000011, 0b010, load, "lw", GPR>;
+defm LOADB  : LOAD<0b0000011, 0b000, extloadi8, "lb", GPR>;
+defm LOADH  : LOAD<0b0000011, 0b001, extloadi16, "lh", GPR>;
+defm LOADF  : LOAD<0b0000111, 0b010, load, "flw", FPR>;
+defm LOADD  : LOAD<0b0000111, 0b011, load, "fld", FPR64>;
