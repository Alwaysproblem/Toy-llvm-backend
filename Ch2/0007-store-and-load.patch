From 0bf41c6012f979a85c6785b8659a5bb3cef2f3c2 Mon Sep 17 00:00:00 2001
From: Alwaysproblem <reganyang0415@gmail.com>
Date: Fri, 9 May 2025 10:03:24 +0000
Subject: [PATCH 07/17] 0009-store-and-load.patch

---
 .../Toy/Disassembler/ToyDisassembler.cpp      | 43 ++++++++++++-
 llvm/lib/Target/Toy/ToyISelDAGToDAG.cpp       | 24 ++++++++
 llvm/lib/Target/Toy/ToyInstrInfo.td           | 61 +++++++++++++++++--
 3 files changed, 121 insertions(+), 7 deletions(-)

diff --git a/llvm/lib/Target/Toy/Disassembler/ToyDisassembler.cpp b/llvm/lib/Target/Toy/Disassembler/ToyDisassembler.cpp
index 5e3e0938c2e1..1a03d24825d3 100644
--- a/llvm/lib/Target/Toy/Disassembler/ToyDisassembler.cpp
+++ b/llvm/lib/Target/Toy/Disassembler/ToyDisassembler.cpp
@@ -60,7 +60,10 @@ static const uint16_t GPRDecoderTable[] = {
 static DecodeStatus DecodeGPRRegisterClass(MCInst &Inst, uint64_t RegNo,
                                            uint64_t Address,
                                            const void *Decoder) {
-  if (RegNo > 31)
+  if (RegNo > 17)
+    return MCDisassembler::Fail;
+
+  if (RegNo == 3 || RegNo == 4)
     return MCDisassembler::Fail;
 
   unsigned Register = GPRDecoderTable[RegNo];
@@ -68,6 +71,44 @@ static DecodeStatus DecodeGPRRegisterClass(MCInst &Inst, uint64_t RegNo,
   return MCDisassembler::Success;
 }
 
+static const uint16_t FPRDecoderTable[] = {
+    Toy::FT0, Toy::FT1, Toy::FT2, 0,        0,        0,
+    0,        0,        Toy::FS0, Toy::FS1, Toy::FA0, Toy::FA1,
+    Toy::FA2, Toy::FA3, Toy::FA4, Toy::FA5, Toy::FA6, Toy::FA7};
+
+static DecodeStatus DecodeFPRRegisterClass(MCInst &Inst, uint64_t RegNo,
+                                           uint64_t Address,
+                                           const void *Decoder) {
+  if (RegNo > 17)
+    return MCDisassembler::Fail;
+
+  if (RegNo == 3 || RegNo == 4 || RegNo == 5 || RegNo == 6 || RegNo == 7)
+    return MCDisassembler::Fail;
+
+  unsigned Register = FPRDecoderTable[RegNo];
+  Inst.addOperand(MCOperand::createReg(Register));
+  return MCDisassembler::Success;
+}
+
+static const uint16_t FPR64DecoderTable[] = {
+    Toy::FT0, Toy::FT1, Toy::FT2, 0,        0,        0,
+    0,        0,        Toy::FS0, Toy::FS1, Toy::FA0, Toy::FA1,
+    Toy::FA2, Toy::FA3, Toy::FA4, Toy::FA5, Toy::FA6, Toy::FA7};
+
+static DecodeStatus DecodeFPR64RegisterClass(MCInst &Inst, uint64_t RegNo,
+                                             uint64_t Address,
+                                             const void *Decoder) {
+  if (RegNo > 17)
+    return MCDisassembler::Fail;
+
+  if (RegNo == 3 || RegNo == 4 || RegNo == 5 || RegNo == 6 || RegNo == 7)
+    return MCDisassembler::Fail;
+
+  unsigned Register = FPR64DecoderTable[RegNo];
+  Inst.addOperand(MCOperand::createReg(Register));
+  return MCDisassembler::Success;
+}
+
 #include "ToyGenDisassemblerTables.inc"
 
 DecodeStatus ToyDisassembler::getInstruction(MCInst &MI, uint64_t &Size,
diff --git a/llvm/lib/Target/Toy/ToyISelDAGToDAG.cpp b/llvm/lib/Target/Toy/ToyISelDAGToDAG.cpp
index c94596035fa6..afde9b332114 100644
--- a/llvm/lib/Target/Toy/ToyISelDAGToDAG.cpp
+++ b/llvm/lib/Target/Toy/ToyISelDAGToDAG.cpp
@@ -38,6 +38,9 @@ public:
   // Override SelectionDAGISel.
   void Select(SDNode *Node) override;
 
+  bool SelectAddrFI(SDNode *Parent, SDValue Addr, SDValue &Base,
+                    SDValue &Offset);
+
 // Include the pieces autogenerated from the target
 // description.
 #include "ToyGenDAGISel.inc"
@@ -74,3 +77,24 @@ void ToyDAGToDAGISel::Select(SDNode *Node) {
   // Select the default instruction.
   SelectCode(Node);
 }
+
+bool ToyDAGToDAGISel::SelectAddrFI(SDNode *Parent, SDValue Addr, SDValue &Base,
+                                   SDValue &Offset) {
+  EVT ValTy = Addr.getValueType();
+  SDLoc DL(Addr);
+  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
+    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), ValTy);
+    Offset = CurDAG->getTargetConstant(0, DL, ValTy);
+    return true;
+  }
+  if (CurDAG->isBaseWithConstantOffset(Addr)) {
+    ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1));
+    if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr.getOperand(0)))
+      Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), ValTy);
+    else
+      Base = Addr.getOperand(0);
+    Offset = CurDAG->getTargetConstant(CN->getZExtValue(), DL, ValTy);
+    return true;
+  }
+  return false;
+}
diff --git a/llvm/lib/Target/Toy/ToyInstrInfo.td b/llvm/lib/Target/Toy/ToyInstrInfo.td
index d06cb338a639..ee42da79a36f 100644
--- a/llvm/lib/Target/Toy/ToyInstrInfo.td
+++ b/llvm/lib/Target/Toy/ToyInstrInfo.td
@@ -43,23 +43,72 @@ class ArithLogicI <bits<7> opcode, bits<3> funct3, string inst, SDNode node>:
       !strconcat(inst, "\t$rd, $rs1, $imm"),
       [(set GPR:$rd, (node GPR:$rs1, imm12:$imm))]>;
 
-def ADDI : ArithLogicI<0b0010011, 0b000, "addi", add>;
-def ANDI : ArithLogicI<0b0010011, 0b111, "andi", and>;
-def ORI  : ArithLogicI<0b0010011, 0b110, "ori",  or>;
-def XORI : ArithLogicI<0b0010011, 0b100, "xori", xor>;
+let isReMaterializable = 1 in {
+  def ADDI : ArithLogicI<0b0010011, 0b000, "addi", add>;
+  def ORI  : ArithLogicI<0b0010011, 0b110, "ori", or>;
+  def XORI : ArithLogicI<0b0010011, 0b100, "xori", xor>;
+}
 
+def ANDI : ArithLogicI<0b0010011, 0b111, "andi", and>;
 
 class ArithLogicR <bits<7> funct7, bits<3> funct3, string inst, SDNode node>:
       InstR<0b0110011, funct7, funct3, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
       !strconcat(inst, "\t$rd, $rs1, $rs2"),
       [(set GPR:$rd, (node GPR:$rs1, GPR:$rs2))]>;
 
-def ADD  : ArithLogicR<0b0000000, 0b000, "add",  add>;
+let isCommutable = 1 in {
+  def ADD  : ArithLogicR<0b0000000, 0b000, "add", add>;
+  def MUL  : ArithLogicR<0b0000001, 0b000, "mul", mul>;
+}
+
 def SUB  : ArithLogicR<0b0100000, 0b000, "sub",  sub>;
-def MUL  : ArithLogicR<0b0000001, 0b000, "mul",  mul>;
 def MULH : ArithLogicR<0b0000001, 0b001, "mulh", mulhs>;
 def DIV  : ArithLogicR<0b0000001, 0b100, "div",  sdiv>;
 def REM  : ArithLogicR<0b0000001, 0b110, "rem",  srem>;
 def AND  : ArithLogicR<0b0000000, 0b111, "and",  and>;
 def OR   : ArithLogicR<0b0000000, 0b110, "or",   or>;
 def XOR  : ArithLogicR<0b0000000, 0b100, "xor",  xor>;
+def SLL  : ArithLogicR<0b0000000, 0b001, "sll",  shl>;
+def SRA  : ArithLogicR<0b0100000, 0b101, "sra",  sra>;
+def SRL  : ArithLogicR<0b0000000, 0b101, "srl",  srl>;
+
+def AddrFI : ComplexPattern<iPTR, 2, "SelectAddrFI", [frameindex], [SDNPWantParent]>;
+
+// load/store for data types
+multiclass STORE<bits<7> opcode, bits<3> funct3, PatFrag op, string asm, DAGOperand ty> {
+  def FI : InstS<opcode, funct3, (outs), 
+           (ins ty:$rs2, GPR:$rs1, imm12:$imm),
+           !strconcat(asm, "\t$rs2, ${imm}(${rs1})"),
+           [(op ty:$rs2, (AddrFI GPR:$rs1, imm12:$imm))]>;
+  def R : InstS<opcode, funct3, (outs),
+          (ins ty:$rs2, GPR:$rs1),
+          !strconcat(asm, "\t$rs2, 0(${rs1})"),
+          [(op ty:$rs2, GPR:$rs1)]> {
+      let imm=0;
+  }
+}
+
+defm STOREW : STORE<0b0100011, 0b010, store,         "sw",  GPR>;
+defm STOREH : STORE<0b0100011, 0b001, truncstorei16, "sh",  GPR>;
+defm STOREB : STORE<0b0100011, 0b000, truncstorei8,  "sb",  GPR>;
+defm STORF  : STORE<0b0100111, 0b010, store,         "fsw", FPR>;
+defm STORD  : STORE<0b0100111, 0b011, store,         "fsd", FPR64>;
+
+multiclass LOAD<bits<7> opcode, bits<3> funct3, PatFrag op, string asm, DAGOperand ty> {
+  def FI : InstI<opcode, funct3, (outs ty:$rd),
+                 (ins GPR:$rs1, imm12:$imm),
+                 !strconcat(asm, "\t$rd, ${imm}(${rs1})"),
+                 [(set ty:$rd, (op (AddrFI GPR:$rs1, imm12:$imm)))]>;
+  def R : InstI<opcode, funct3,
+                (outs ty:$rd), (ins GPR:$rs1),
+                !strconcat(asm, "\t$rd, 0(${rs1})"),
+                [(set ty:$rd, (op GPR:$rs1))]>{
+      let imm=0;
+  }
+}
+
+defm LOADW  : LOAD<0b0000011, 0b010, load,       "lw",  GPR>;
+defm LOADB  : LOAD<0b0000011, 0b000, extloadi8,  "lb",  GPR>;
+defm LOADH  : LOAD<0b0000011, 0b001, extloadi16, "lh",  GPR>;
+defm LOADF  : LOAD<0b0000111, 0b010, load,       "flw", FPR>;
+defm LOADD  : LOAD<0b0000111, 0b011, load,       "fld", FPR64>;
-- 
2.34.1

